二叉查找树(binary search tree)：当前根节点的左边全部比根节点小，当前根节点的右边全部比根节点大。

~~~
class TreeNode {
	constructor(data) {
    this.data = data;
    this.left = null;
    this.right = null;
  }
}

class BinarySearchTree {
	constructor() {
		this.root = null;
  }

  insert(data){
  	var newNode = new TreeNode(data);
  	if(this.root === null){
  		this.root = newNode;
  	}else{
  		this.insertNode(this.root,newNode);
  	}
  }

  insertNode(node,newNode){
  	if(newNode.data < node.data){
  		if(node.left === null){
  			node.left = newNode;
  		}else{
  			this.insertNode(node.left, newNode);
  		}
  	}else{
  		if(node.right === null){
  			node.right = newNode;
  		}else{
  			this.insertNode(node.right, newNode);
  		}
  	}
  }

  remove(data){
  	this.root = this.removeNode(this.root,data);
  }

  removeNode(node,data){
  	if(node === null){
  		return null;
  	}else if(data < node.data){
  		node.left = this.removeNode(node.left,data);
  		return node;
  	}else if(data > node.data){
  		node.right = this.removeNode(node.right,data);
  		return node;
  	}else{
  		if(node.left === null && node.right === null){
  			node = null;
  			return node;
  		}
  		if(node.left === null){
  			node = node.right;
  			return node;
  		}else if(node.right === null){
  			node = node.left;
  			return node;
  		}
  		// Deleting node with two children
      // minumum node of the rigt subtree
      // is stored in aux
      var aux = this.findMinNode(node.right);
      node.data = aux.data;

      node.right = this.removeNode(node.right, aux.data);
      return node;
  	}
  }

  findMinNode(node){
  	if(node.left === null){
  		return node;
  	}else{
  		return this.findMinNode(node.left);
  	}
  }

  getRootNode(){
  	return this.root;
  }

  inorder(node){ //中序（左->根->右）
  	if(node != null){
  		this.inorder(node.left);
  		console.log(node.data);
  		this.inorder(node.right);
  	}
  }

  preorder(node){ //前序（根->左->右）
  	if(node != null){
  		console.log(node.data);
  		this.preorder(node.left);
  		this.preorder(node.right);
  	}
  } 

  postorder(node){ //后序（左->右->根）
  	if(node != null){
  		this.postorder(node.left);
  		this.postorder(node.right);
  		console.log(node.data);
  	}
  }

  search(node,data){
  	if(node === null){
  		return null;
  	}else if(data < node.data){
  		return this.search(node.left,data);
  	}else if(data > node.data){
  		return this.search(node.right,data);
  	}else{
  		return node;
  	}
  }
}

// create an object for the BinarySearchTree
var BST = new BinarySearchTree();

// Inserting nodes to the BinarySearchTree
BST.insert(15);
BST.insert(25);
BST.insert(10);
BST.insert(7);
BST.insert(22);
BST.insert(17);
BST.insert(13);
BST.insert(5);
BST.insert(9);
BST.insert(27);

//          15
//         /  \
//        10   25
//       / \   / \
//      7  13 22  27
//     / \    /
//    5   9  17 


var root = BST.getRootNode();

BST.inorder(root); // 5 7 9 10 13 15 17 22 25 27

// Removing node with no children
BST.remove(5);
//          15
//         /  \
//        10   25
//       / \   / \
//      7  13 22  27
//       \    /
//        9  17

var root = BST.getRootNode();
BST.inorder(root); // 7 9 10 13 15 17 22 25 27

// Removing node with one children
BST.remove(7);
//          15
//         /  \
//        10   25
//       / \   / \
//      9  13 22  27
//            /
//           17 

var root = BST.getRootNode();
BST.inorder(root); //9 10 13 15 17 22 25 27
             
// Removing node with two children              
BST.remove(15);
//          17
//         /  \
//        10   25
//       / \   / \
//      9  13 22  27

var root = BST.getRootNode();

console.log("inorder traversal");
BST.inorder(root); //9 10 13 17 22 25 27
             
console.log("postorder traversal");
BST.postorder(root); // 9 13 10 22 27 25 17

console.log("preorder traversal");
BST.preorder(root); // 17 10 9 13 25 22 27

~~~

# 更多

Javascript实现二叉查找树：
https://www.geeksforgeeks.org/implementation-binary-search-tree-javascript/

二叉查找树：
https://gist.github.com/benlesh/9128359
https://khan4019.github.io/front-end-Interview-Questions/bst.html

binary-search-tree-javascript
https://reactgo.com/binary-search-tree-javascript/